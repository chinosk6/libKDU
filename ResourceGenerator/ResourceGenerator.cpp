#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <regex>
#include <sstream>
#include <iomanip>
#include "trim.h"

// yes, I'm lazy and this isn't mission critical, 
// so half of this code is just Github copilot speedrun

struct Resource {
    std::string name;
    std::string path;
};

std::vector<Resource> ParseResourceFile(std::string path) {
    std::vector<Resource> resources;
    std::ifstream resourceFile(path);
    if (!resourceFile.is_open()) {
        std::cout << "Failed to open resource file: " << path << std::endl;
        return resources;
    }
    std::string line;
    while (std::getline(resourceFile, line)) {
        if (line.find("RCDATA") != std::string::npos) {
            std::regex regex("\\s+");
            std::vector<std::string> tokens(std::sregex_token_iterator(line.begin(), line.end(), regex, -1), std::sregex_token_iterator());
            if (tokens.size() >= 3) {
                std::string resourceName = trim_copy(tokens[0]);
                std::string resourcePath = trim_copy(tokens[2]);

                // remove quotes
                resourcePath = std::regex_replace(resourcePath, std::regex("\""), "");
                // remove duplicate slashes
                resourcePath = std::regex_replace(resourcePath, std::regex("\\\\\\\\"), "\\");

                resources.push_back({ resourceName, resourcePath });
            }
        }
    }
    return resources;
}

std::string GenerateResourceBuffer(std::string filePath, std::string name) {
    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open()) {
        std::cout << "Failed to open file: " << filePath << std::endl;
        return "";
    }
    std::vector<unsigned char> buffer(std::istreambuf_iterator<char>(file), {});

    std::stringstream outputData;
    outputData << "const unsigned char " << name << "_DATA[] = {\n\t";
    for (int i = 0; i < buffer.size(); i++) {
        if (i % 16 == 0 && i != 0) {
            outputData << "\n\t";
        }
        outputData << "0x" << std::setfill('0') << std::setw(2) << std::hex << (int)buffer[i] << ", ";
    }
    outputData << "\n};\n\n";

    return outputData.str();
}

int main(int argc, char* argv[]) {
    // print args
    if (argc != 4) {
        std::cout << "Usage: ResourceGenerator.exe <output_path> <resource_file1> <resource_name>" << std::endl;
        return 1;
    }
    std::string outputPath = argv[1];
    std::string resourceFile = argv[2];
    std::string resourceName = argv[3];
    std::string resourceDir = resourceFile.substr(0, resourceFile.find_last_of("\\/"));

    std::vector<Resource> resources = ParseResourceFile(resourceFile);

    std::stringstream outputData;
    outputData << "// Generated by ResourceGenerator\n";
    outputData << "#include <" << resourceName << "/resource.h>\n";
    outputData << "#include <unordered_map>\n";
    outputData << "#include <tuple>\n\n";

    for (auto resource : resources) {
        std::string resourcePath = resourceDir + "\\" + resource.path;
        std::string resourceBuffer = GenerateResourceBuffer(resourcePath, resource.name);
        if (resourceBuffer == "") {
            return 1;
        }
        outputData << resourceBuffer;
    }

    outputData << "std::unordered_map<int, std::tuple<size_t, const unsigned char*>> " << resourceName << "_resources = {\n";
    for (auto resource : resources) {
        outputData << "\t{" << resource.name << ", {sizeof(" << resource.name << "_DATA), " << resource.name << "_DATA}},\n";
    }
    outputData << "};\n";

    std::ofstream outputFile(outputPath);
    if (!outputFile.is_open()) {
        std::cout << "Failed to open output file: " << outputPath << std::endl;
        return 1;
    }
    outputFile << outputData.str();
    outputFile.close();

    return 0;
}
